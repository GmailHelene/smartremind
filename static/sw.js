from flask import Flask, render_template, send_from_directory, request, redirect, url_for, flash, jsonify, session
from flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user
from flask_mail import Mail, Message
from flask_wtf import FlaskForm
from flask_wtf.csrf import CSRFProtect
from wtforms import StringField, TextAreaField, SelectField, DateField, TimeField, PasswordField, SubmitField
from wtforms.validators import DataRequired, Email, Length
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime, timedeltan(event) {
from apscheduler.schedulers.background import BackgroundScheduler
import jsonhes.open(CACHE_NAME)
import uuid .then(function(cache) {
import re       return cache.addAll(urlsToCache);
import os   })
import logging
from pathlib import Path
import random
import stringListener('fetch', function(event) {
import psutilpondWith(
from datetime import datetime, timedelta
            .then(function(response) {
try:            return response || fetch(event.request);
    import psycopg2
    from psycopg2 import pool
except ImportError:
    psycopg2 = None
    pool = None# Logginglogging.basicConfig(level=logging.INFO)logger = logging.getLogger(__name__)# Flask Appapp = Flask(__name__)# Fix the SECRET_KEY - ensure it's a bytes objectimport osimport secrets# Generate a secure random key if none exists in environmentapp.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', '').encode() or secrets.token_hex(16).encode()    # Fix database URL permanentdef fix_database_url():    database_url = os.getenv('DATABASE_URL')    if database_url and 'postgres.railway.internal' in database_url:        pghost = os.getenv('PGHOST')        if pghost:            fixed_url = database_url.replace('postgres.railway.internal', pghost)            os.environ['DATABASE_URL'] = fixed_url            logger.info(f"Fixed DATABASE_URL: {fixed_url}")        else:            logger.warning("PGHOST not found, using individual variables")# Fix database URL before anything elsefix_database_url()# Database connection setupdatabase_url = os.getenv('DATABASE_URL')if not database_url:    database_url = f"postgresql://{os.getenv('PGUSER')}:{os.getenv('PGPASSWORD')}@{os.getenv('PGHOST')}:{os.getenv('PGPORT')}/{os.getenv('PGDATABASE')}"# Connection pool for better performanceconnection_pool = Noneif psycopg2 and database_url:    try:        connection_pool = psycopg2.pool.SimpleConnectionPool(            1, 3,  # Min 1, Max 3 connections            database_url        )        logger.info("Database connection pool created")    except Exception as e:        logger.error(f"Failed to create connection pool: {e}")def get_db_connection():    """Get database connection from pool"""    if connection_pool:        try:            return connection_pool.getconn()        except Exception as e:            logger.error(f"Database connection error: {e}")    return Nonedef return_db_connection(conn):    """Return connection to pool"""    if connection_pool and conn:        connection_pool.putconn(conn)# I app.py - s칮rg for at static files serveres riktig@app.route('/static/<path:filename>')def static_files(filename):    return send_from_directory('static', filename)# Eller bruk Flask's innebygde static servingapp = Flask(__name__, static_folder='static', static_url_path='/static')# I app.py, legg til route for service worker@app.route('/sw.js')def service_worker():    return send_from_directory('static/js', 'sw.js')@app.route('/manifest.json')def manifest():    return send_from_directory('static', 'manifest.json')    # Serve ikoner@app.route('/images/<path:filename>')def serve_icons(filename):    return send_from_directory('static/icons', filename)# E-post konfigureringapp.config['MAIL_SERVER'] = 'smtp.gmail.com'app.config['MAIL_PORT'] = 587app.config['MAIL_USE_TLS'] = Trueapp.config['MAIL_USERNAME'] = os.environ.get('MAIL_USERNAME')app.config['MAIL_PASSWORD'] = os.environ.get('MAIL_PASSWORD')app.config['MAIL_DEFAULT_SENDER'] = os.environ.get('MAIL_USERNAME')# P친minnelse innstillingerapp.config['NOTIFICATION_ADVANCE_MINUTES'] = 30app.config['REMINDER_CHECK_INTERVAL'] = 900  # 15 minutes instead of 5# Extensionscsrf = CSRFProtect(app)mail = Mail(app)login_manager = LoginManager(app)login_manager.login_view = 'login'login_manager.login_message = 'Vennligst logg inn for 친 f친 tilgang til denne siden.'login_manager.login_message_category = 'info'# Data Manager for JSON fallbackclass DataManager:    def __init__(self):        self.data_dir = Path('data')        self.data_dir.mkdir(exist_ok=True)        self._ensure_data_files()    # Replace the _ensure_data_files method    def _ensure_data_files(self):        """S칮rg for at alle data-filer eksisterer"""        files = ['users', 'reminders', 'shared_reminders', 'notifications', 'email_log', 'shared_notes']        for filename in files:            filepath = self.data_dir / f"{filename}.json"            if not filepath.exists():                initial_data = {} if filename == 'users' else []                with open(filepath, 'w', encoding='utf-8') as f:                    json.dump(initial_data, f, ensure_ascii=False)           def load_data(self, filename):        """Last inn data fra JSON-fil med error handling"""        filepath = self.data_dir / f"{filename}.json"        try:            with open(filepath, 'r', encoding='utf-8') as f:                return json.load(f)        except (FileNotFoundError, json.JSONDecodeError) as e:            logger.error(f"Feil ved lasting av {filename}: {e}")            return [] if filename in ['reminders', 'shared_reminders', 'notifications', 'email_log', 'shared_notes'] else {}    def save_data(self, filename, data):        """Lagre data til JSON-fil"""        filepath = self.data_dir / f"{filename}.json"        try:            with open(filepath, 'w', encoding='utf-8') as f:                json.dump(data, f, ensure_ascii=False, indent=2)        except Exception as e:            logger.error(f"Feil ved lagring av {filename}: {e}")            raise# Global data managerdm = DataManager()# Database initializationdef init_db():    if not psycopg2:        logger.warning("psycopg2 not installed - using JSON storage")        return False            conn = get_db_connection()    if not conn:        logger.warning("No database connection - using JSON storage")        return False            try:        cur = conn.cursor()                # Create users table        cur.execute('''        CREATE TABLE IF NOT EXISTS users (            id TEXT PRIMARY KEY,            username TEXT NOT NULL,            email TEXT UNIQUE NOT NULL,            password_hash TEXT NOT NULL,            created TIMESTAMP DEFAULT CURRENT_TIMESTAMP        )        ''')                # Create user_profiles table        cur.execute('''        CREATE TABLE IF NOT EXISTS user_profiles (            id SERIAL PRIMARY KEY,            user_id TEXT REFERENCES users(id),            profile_type TEXT DEFAULT 'standard',            preferences JSONB DEFAULT '{}',            accessibility_settings JSONB DEFAULT '{}'        )        ''')                # Create reminders table        cur.execute('''        CREATE TABLE IF NOT EXISTS reminders (            id TEXT PRIMARY KEY,            user_id TEXT REFERENCES users(id),            title TEXT NOT NULL,            description TEXT,            due_date TIMESTAMP,            category TEXT DEFAULT 'general',            priority TEXT DEFAULT 'medium',            completed BOOLEAN DEFAULT FALSE,            difficulty_level INTEGER DEFAULT 1,            estimated_duration INTEGER DEFAULT 15,            energy_level TEXT DEFAULT 'medium',            context_tags TEXT[],            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP        )        ''')                # Create focus_sessions table        cur.execute('''        CREATE TABLE IF NOT EXISTS focus_sessions (            id SERIAL PRIMARY KEY,            user_id TEXT REFERENCES users(id),            session_type TEXT DEFAULT 'pomodoro',            duration_minutes INTEGER,            started_at TIMESTAMP,            completed_at TIMESTAMP,            completed BOOLEAN DEFAULT FALSE,            notes TEXT        )        ''')                # Create user_statistics table        cur.execute('''        CREATE TABLE IF NOT EXISTS user_statistics (            id SERIAL PRIMARY KEY,            user_id TEXT REFERENCES users(id),            date DATE,            focus_sessions_completed INTEGER DEFAULT 0,            total_focus_time INTEGER DEFAULT 0,            points INTEGER DEFAULT 0,            UNIQUE(user_id, date)        )        ''')                conn.commit()        cur.close()        logger.info("Database tables initialized!")        return True    except Exception as e:        logger.error(f"Database initialization error: {e}")        return False    finally:        return_db_connection(conn)# Initialize databaseuse_db = init_db()# WTFormsclass LoginForm(FlaskForm):    username = StringField('Brukernavn/E-post', validators=[DataRequired(), Email()])    password = PasswordField('Passord', validators=[DataRequired()])    submit = SubmitField('Logg inn')class RegisterForm(FlaskForm):    username = StringField('Brukernavn/E-post', validators=[DataRequired(), Email()])    password = PasswordField('Passord', validators=[DataRequired(), Length(min=6)])    submit = SubmitField('Registrer deg')class ReminderForm(FlaskForm):    title = StringField('Tittel', validators=[DataRequired()])    description = TextAreaField('Beskrivelse')    date = DateField('Dato', validators=[DataRequired()], default=datetime.now().date())    time = TimeField('Tid', validators=[DataRequired()], default=datetime.now().time())    priority = SelectField('Prioritet', choices=[('Lav', 'Lav'), ('Medium', 'Medium'), ('H칮y', 'H칮y')])    category = SelectField('Kategori', choices=[        ('Jobb', 'Jobb'), ('Privat', 'Privat'), ('Helse', 'Helse'),         ('Familie', 'Familie'), ('Annet', 'Annet')    ])    submit = SubmitField('Opprett p친minnelse')class NoteForm(FlaskForm):    title = StringField('Tittel', validators=[DataRequired()])    content = TextAreaField('Notat', validators=[DataRequired()])    share_with = StringField('Del med (e-post)')    submit = SubmitField('Lagre notat')# User Classclass User(UserMixin):    def __init__(self, user_id, username, email, password_hash=None):        self.id = user_id        self.username = username        self.email = email        self.password_hash = password_hash        def check_password(self, password):        return check_password_hash(self.password_hash, password)        @staticmethod    def get(user_id):        # Try database first        conn = get_db_connection()        if conn:            try:                cur = conn.cursor()                cur.execute('SELECT id, username, email, password_hash FROM users WHERE id = %s', (user_id,))                user = cur.fetchone()                cur.close()                                if user:                    return User(user[0], user[1], user[2], user[3])            except Exception as e:                logger.error(f"Database error in User.get: {e}")            finally:                return_db_connection(conn)                # Fallback to JSON        users = dm.load_data('users')        if user_id in users:            user_data = users[user_id]            return User(user_id, user_data['username'], user_data['email'], user_data.get('password_hash'))        return None        @staticmethod    def get_by_email(email):        # Try database first        conn = get_db_connection()        if conn:            try:                cur = conn.cursor()                cur.execute('SELECT id, username, email, password_hash FROM users WHERE email = %s', (email,))                user = cur.fetchone()                cur.close()                                if user:                    return User(user[0], user[1], user[2], user[3])            except Exception as e:                logger.error(f"Database error in User.get_by_email: {e}")            finally:                return_db_connection(conn)                # Fallback to JSON        users = dm.load_data('users')        for user_id, user_data in users.items():            if user_data['email'] == email:                return User(user_id, user_data['username'], user_data['email'], user_data.get('password_hash'))        return None    def save(self):        """Save user to database and JSON"""        # Save to database if available        conn = get_db_connection()        if conn:            try:                cur = conn.cursor()                cur.execute(                    'INSERT INTO users (id, username, email, password_hash) VALUES (%s, %s, %s, %s) ON CONFLICT (email) DO NOTHING',                    (self.id, self.username, self.email, self.password_hash)                )                conn.commit()                cur.close()                logger.info(f"User {self.email} saved to database")                return True            except Exception as e:                logger.error(f"Database error saving user: {e}")            finally:                return_db_connection(conn)                # Always save to JSON as backup        users = dm.load_data('users')        users[self.id] = {            'username': self.username,            'email': self.email,            'password_hash': self.password_hash,            'created': datetime.now().isoformat()        }        dm.save_data('users', users)        logger.info(f"User {self.email} saved to JSON")        return True@login_manager.user_loaderdef load_user(user_id):    return User.get(user_id)# Email functionsdef send_email(to, subject, template=None, html_content=None, **kwargs):    """Send email with template or direct HTML"""    try:        if not app.config['MAIL_USERNAME'] or not app.config['MAIL_PASSWORD']:            logger.warning(f"Email not sent: Missing MAIL_USERNAME or MAIL_PASSWORD")            return False                # Email validation        if not to or (isinstance(to, str) and '@' not in to) or (isinstance(to, list) and not all('@' in recipient for recipient in to)):            logger.warning(f"Invalid email address: {to}")            return False                    msg = Message(            subject=subject,            recipients=[to] if isinstance(to, str) else to,            sender=app.config['MAIL_DEFAULT_SENDER'] or app.config['MAIL_USERNAME']        )                if template:            msg.html = render_template(template, **kwargs)        elif html_content:            msg.html = html_content        else:            logger.error("Email missing both template and HTML content")            return False                    mail.send(msg)        logger.info(f"Email sent to {to}: {subject}")        return True            except Exception as e:        logger.error(f"Error sending email to {to}: {e}")        return Falsedef check_reminders_for_notifications():    """Check reminders and send notifications with memory logging"""    with app.app_context():        try:            # Log memory usage            import psutil            process = psutil.Process()            memory_mb = process.memory_info().rss / 1024 / 1024            logger.info(f"Memory usage before reminder check: {memory_mb:.2f} MB")                        now = datetime.now()            notification_time = now + timedelta(minutes=app.config['NOTIFICATION_ADVANCE_MINUTES'])                        reminders = dm.load_data('reminders')            shared_reminders = dm.load_data('shared_reminders')            notifications = dm.load_data('notifications')                        sent_notifications = {n['reminder_id'] for n in notifications}            all_reminders = []                        # Process reminders            for reminder in reminders:                if not reminder['completed'] and reminder['id'] not in sent_notifications:                    try:                        reminder_dt = datetime.fromisoformat(reminder['datetime'].replace(' ', 'T'))                        if now <= reminder_dt <= notification_time:                            if reminder['user_id'] and '@' in reminder['user_id']:                                all_reminders.append((reminder, reminder['user_id']))                    except (ValueError, KeyError) as e:                        logger.warning(f"Invalid reminder datetime: {e}")                        # Process shared reminders            for reminder in shared_reminders:                if not reminder['completed'] and reminder['id'] not in sent_notifications:                    try:                        reminder_dt = datetime.fromisoformat(reminder['datetime'].replace(' ', 'T'))                        if now <= reminder_dt <= notification_time:                            if reminder['shared_with'] and '@' in reminder['shared_with']:                                all_reminders.append((reminder, reminder['shared_with']))                    except (ValueError, KeyError) as e:                        logger.warning(f"Invalid shared reminder datetime: {e}")                        # Send notifications (limit to 5 per run to prevent memory issues)            sent_count = 0            for reminder, recipient_email in all_reminders[:5]:                subject = f"游댒 P친minnelse: {reminder['title']}"                html_content = f"""                <h2>P친minnelse: {reminder['title']}</h2>                <p>Dette er en p친minnelse om at du har en oppgave som snart forfaller.</p>                <div style="background: #f8f9fa; padding: 15px; border-radius: 5px;">                    <h3>{reminder['title']}</h3>                    <p><strong>Beskrivelse:</strong> {reminder.get('description', 'Ingen beskrivelse')}</p>                    <p><strong>Tid:</strong> {reminder['datetime']}</p>                    <p><strong>Prioritet:</strong> {reminder['priority']}</p>                </div>                """                                success = send_email(                    to=recipient_email,                    subject=subject,                    html_content=html_content                )                                if success:                    notifications.append({                        'reminder_id': reminder['id'],                        'recipient': recipient_email,                        'sent_at': now.isoformat(),                        'type': 'reminder_notification'                    })                    sent_count += 1                        # Save updated notifications            if sent_count > 0:                dm.save_data('notifications', notifications)                logger.info(f"Sent {sent_count} reminder notifications")                        # Log memory usage after            memory_mb_after = process.memory_info().rss / 1024 / 1024            logger.info(f"Memory usage after reminder check: {memory_mb_after:.2f} MB")                    except Exception as e:            logger.error(f"Error checking reminders: {e}")# Initialize scheduler with reduced frequencyscheduler = BackgroundScheduler()scheduler.add_job(    func=check_reminders_for_notifications,    trigger="interval",    minutes=15,  # Reduced from 5 to 15 minutes    id='check_reminders_for_notifications')scheduler.start()# Helper functionsdef get_user_profile(user_id):    """Get user profile or create default"""    conn = get_db_connection()    if not conn:        return {            'id': None,            'user_id': user_id,            'profile_type': 'standard',            'preferences': {},            'accessibility_settings': {}        }        try:        cursor = conn.cursor()        cursor.execute("""            SELECT id, user_id, profile_type, preferences, accessibility_settings            FROM user_profiles WHERE user_id = %s        """, (user_id,))                profile = cursor.fetchone()                if profile:            return {                'id': profile[0],                'user_id': profile[1],                'profile_type': profile[2],                'preferences': profile[3] if profile[3] else {},                'accessibility_settings': profile[4] if profile[4] else {}            }        else:            # Create default profile            cursor.execute("""                INSERT INTO user_profiles (user_id, profile_type, preferences)                VALUES (%s, 'standard', '{}')                RETURNING id, profile_type, preferences            """, (user_id,))                        new_profile = cursor.fetchone()            conn.commit()                        return {                'id': new_profile[0],                'user_id': user_id,                'profile_type': new_profile[1],                'preferences': {},                'accessibility_settings': {}            }                except Exception as e:        logger.error(f"Error getting user profile: {e}")        return {            'id': None,            'user_id': user_id,            'profile_type': 'standard',            'preferences': {},            'accessibility_settings': {}        }    finally:        cursor.close()        return_db_connection(conn)def get_user_reminders(user_id):    """Get user's reminders"""    # Try database first    conn = get_db_connection()    if conn:        try:            cursor = conn.cursor()            cursor.execute("""                SELECT id, title, description, due_date, category, priority, completed                FROM reminders WHERE user_id = %s                ORDER BY due_date ASC            """, (user_id,))                        reminders = cursor.fetchall()            cursor.close()            return [{'id': r[0], 'title': r[1], 'description': r[2],                     'datetime': r[3], 'category': r[4], 'priority': r[5],                     'completed': r[6]} for r in reminders]        except Exception as e:            logger.error(f"Error getting user reminders: {e}")        finally:            return_db_connection(conn)        # Fallback to JSON    reminders = dm.load_data('reminders')    user_email = User.get(user_id).email if User.get(user_id) else None    return [r for r in reminders if r.get('user_id') == user_email]def get_shared_reminders(user_id):    """Get reminders shared with user"""    shared_reminders = dm.load_data('shared_reminders')    user_email = User.get(user_id).email if User.get(user_id) else None    return [r for r in shared_reminders if r.get('shared_with') == user_email]def calculate_user_stats(user_id):    """Calculate user statistics"""    conn = get_db_connection()    if not conn:        return {            'total': 0, 'completed': 0, 'shared_count': 0, 'completion_rate': 0,            'completed_today': 0, 'sessions_today': 0, 'total_time_today': 0, 'streak_days': 0        }        try:        cursor = conn.cursor()                # Total reminders        cursor.execute("SELECT COUNT(*) FROM reminders WHERE user_id = %s", (user_id,))        total = cursor.fetchone()[0]                # Completed reminders        cursor.execute("SELECT COUNT(*) FROM reminders WHERE user_id = %s AND completed = TRUE", (user_id,))        completed = cursor.fetchone()[0]                completion_rate = (completed / total * 100) if total > 0 else 0                cursor.close()        return {            'total': total,            'completed': completed,            'shared_count': 0,            'completion_rate': completion_rate,            'completed_today': 0,            'sessions_today': 0,            'total_time_today': 0,            'streak_days': 0        }            except Exception as e:        logger.error(f"Error calculating stats: {e}")        return {            'total': 0, 'completed': 0, 'shared_count': 0, 'completion_rate': 0,            'completed_today': 0, 'sessions_today': 0, 'total_time_today': 0, 'streak_days': 0        }    finally:        return_db_connection(conn)def get_user_notes(user_id, limit=None):    """Get user's notes"""    notes = dm.load_data('shared_notes')    user_email = User.get(user_id).email if User.get(user_id) else None    user_notes = [n for n in notes if n.get('user_id') == user_email]    return user_notes[:limit] if limit else user_notesdef get_shared_notes(user_id, limit=None):    """Get notes shared with user"""    notes = dm.load_data('shared_notes')    user_email = User.get(user_id).email if User.get(user_id) else None    shared_notes = [n for n in notes if user_email in n.get('shared_with', [])]    return shared_notes[:limit] if limit else shared_notesdef get_focus_stats(user_id):    """Get focus session statistics"""    return {'sessions_today': 0, 'total_time_today': 0}def get_available_users(user_id):    """Get available users for sharing"""    return []def get_dashboard_config(profile):    """Get dashboard configuration based on profile"""    return {}def award_points(user_id, action, value=1):    """Award points for various actions"""    points_map = {        'focus_session_completed': value * 2,        'reminder_completed': 5,        'daily_streak': 20,        'weekly_goal': 50    }        points = points_map.get(action, 0)        conn = get_db_connection()    if not conn:        return points        try:        cursor = conn.cursor()        cursor.execute("""            INSERT INTO user_statistics (user_id, date, points)            VALUES (%s, CURRENT_DATE, %s)            ON CONFLICT (user_id, date)             DO UPDATE SET points = COALESCE(user_statistics.points, 0) + %s        """, (user_id, points, points))                conn.commit()        cursor.close()    except Exception as e:        logger.error(f"Error awarding points: {e}")    finally:        return_db_connection(conn)        return points# Routes@app.route('/')def index():    return render_template('index.html')@app.route('/login', methods=['GET', 'POST'])def login():    form = LoginForm()        if form.validate_on_submit():        user = User.get_by_email(form.username.data)                if user and user.check_password(form.password.data):            login_user(user, remember=True)            next_page = request.args.get('next')            flash(f'Velkommen tilbake, {user.username}!', 'success')            return redirect(next_page) if next_page else redirect(url_for('dashboard'))        else:            flash('Feil e-post eller passord!', 'error')        return render_template('login.html', form=form)@app.route('/register', methods=['GET', 'POST'])def register():    form = RegisterForm()        if form.validate_on_submit():        if User.get_by_email(form.username.data):            flash('E-post er allerede registrert!', 'error')            return render_template('login.html', form=LoginForm(), register_form=form)                user_id = str(uuid.uuid4())        password_hash = generate_password_hash(form.password.data)                user = User(user_id, form.username.data, form.username.data, password_hash)        user.save()                login_user(user, remember=True)                flash(f'Velkommen, {user.username}! Din konto er opprettet.', 'success')        return redirect(url_for('dashboard'))        return redirect(url_for('login'))@app.route('/logout')@login_requireddef logout():    logout_user()    flash('Du er n친 logget ut.', 'info')    return redirect(url_for('login'))@app.route('/dashboard')@login_requireddef dashboard():    # Get user profile    profile = get_user_profile(current_user.id)        # Get reminders    my_reminders = get_user_reminders(current_user.id)    shared_reminders = get_shared_reminders(current_user.id)        # Get notes    my_notes = get_user_notes(current_user.id, limit=3)    shared_notes = get_shared_notes(current_user.id, limit=3)        # Calculate statistics    stats = calculate_user_stats(current_user.id)        # Create form    form = ReminderForm()        return render_template('dashboard.html',                          form=form,                          my_reminders=my_reminders,                         shared_reminders=shared_reminders,                         stats=stats,                         current_time=datetime.now(),                         profile=profile,                         my_notes=my_notes,                         shared_notes=shared_notes)@app.route('/add_reminder', methods=['POST'])@login_requireddef add_reminder():    form = ReminderForm()        if form.validate_on_submit():        share_with = request.form.getlist('share_with')                reminder_id = str(uuid.uuid4())        new_reminder = {            'id': reminder_id,            'user_id': current_user.email,            'title': form.title.data,            'description': form.description.data,            'datetime': f"{form.date.data} {form.time.data}",            'priority': form.priority.data,            'category': form.category.data,            'completed': False,            'created': datetime.now().isoformat(),            'shared_with': share_with        }                reminders = dm.load_data('reminders')        reminders.append(new_reminder)        dm.save_data('reminders', reminders)                if share_with:            shared_reminders = dm.load_data('shared_reminders')                        for recipient in share_with:                shared_reminder = {                    'id': str(uuid.uuid4()),                    'original_id': reminder_id,                    'shared_by': current_user.email,                    'shared_with': recipient,                    'title': form.title.data,                    'description': form.description.data,                    'datetime': f"{form.date.data} {form.time.data}",                    'priority': form.priority.data,                    'category': form.category.data,                    'completed': False,                    'created': datetime.now().isoformat(),                    'is_shared': True                }                shared_reminders.append(shared_reminder)                        dm.save_data('shared_reminders', shared_reminders)            flash(f'P친minnelse "{form.title.data}" opprettet og delt med {len(share_with)} personer!', 'success')        else:            flash(f'P친minnelse "{form.title.data}" opprettet!', 'success')    else:        flash('Feil i skjema. Sjekk alle felt.', 'error')        return redirect(url_for('dashboard'))@app.route('/complete_reminder/<reminder_id>')@login_requireddef complete_reminder(reminder_id):    # Check my reminders    reminders = dm.load_data('reminders')    for reminder in reminders:        if reminder['id'] == reminder_id and reminder['user_id'] == current_user.email:            reminder['completed'] = True            reminder['completed_at'] = datetime.now().isoformat()            dm.save_data('reminders', reminders)            flash('P친minnelse fullf칮rt!', 'success')            return redirect(url_for('dashboard'))        # Check shared reminders    shared_reminders = dm.load_data('shared_reminders')    for reminder in shared_reminders:        if reminder['id'] == reminder_id and reminder['shared_with'] == current_user.email:            reminder['completed'] = True            reminder['completed_at'] = datetime.now().isoformat()            dm.save_data('shared_reminders', shared_reminders)            flash('Delt p친minnelse fullf칮rt!', 'success')            return redirect(url_for('dashboard'))        flash('P친minnelse ikke funnet!', 'error')    return redirect(url_for('dashboard'))@app.route('/delete_reminder/<reminder_id>')@login_requireddef delete_reminder(reminder_id):    reminders = dm.load_data('reminders')    original_count = len(reminders)        reminders = [r for r in reminders if not (r['id'] == reminder_id and r['user_id'] == current_user.email)]        if len(reminders) < original_count:        dm.save_data('reminders', reminders)        flash('P친minnelse slettet!', 'success')    else:        flash('P친minnelse ikke funnet eller tilh칮rer ikke deg!', 'error')        return redirect(url_for('dashboard'))@app.route('/notes')@login_requireddef notes():    notes = dm.load_data('shared_notes')    my_notes = [n for n in notes if n.get('user_id') == current_user.email]    shared_with_me = [n for n in notes if current_user.email in n.get('shared_with', [])]        form = NoteForm()        return render_template('notes.html',                           form=form,                          my_notes=my_notes,                          shared_notes=shared_with_me)@app.route('/add_note', methods=['POST'])@login_requireddef add_note():    form = NoteForm()        if form.validate_on_submit():        share_with = []        if form.share_with.data:            share_with = [email.strip() for email in form.share_with.data.split(',')]                note_id = str(uuid.uuid4())        new_note = {            'id': note_id,            'user_id': current_user.email,            'title': form.title.data,            'content': form.content.data,            'created': datetime.now().isoformat(),            'updated': datetime.now().isoformat(),            'shared_with': share_with        }                notes = dm.load_data('shared_notes')        notes.append(new_note)        dm.save_data('shared_notes', notes)                flash('Notat opprettet!', 'success')        return redirect(url_for('notes'))@app.route('/profile-setup')@login_requireddef profile_setup():    """Show profile selection for new users"""    return render_template('profile_setup.html')@app.route('/profile-setup', methods=['POST'])@login_requireddef profile_setup_post():    """Handle profile selection"""    profile_type = request.form.get('profile_type')    accessibility_needs = request.form.getlist('accessibility')        flash(f'Profil konfigurert som {profile_type}!', 'success')    return redirect(url_for('dashboard'))@app.route('/focus-mode')@login_requireddef focus_mode():    """Focus mode for ADHD/students"""    profile = get_user_profile(current_user.id)    return render_template('focus_mode.html', profile=profile)@app.route('/start-focus-session', methods=['POST'])@login_requireddef start_focus_session():    """Start a focus session"""    session_type = request.form.get('session_type', 'pomodoro')    duration = int(request.form.get('duration', 25))        conn = get_db_connection()    if not conn:        return jsonify({'error': 'Database not available'}), 500        try:        cur = conn.cursor()        cur.execute("""            INSERT INTO focus_sessions (user_id, session_type, duration_minutes, started_at)            VALUES (%s, %s, %s, %s) RETURNING id        """, (current_user.id, session_type, duration, datetime.now()))                session_id = cur.fetchone()[0]        conn.commit()        cur.close()                return jsonify({'session_id': session_id, 'duration': duration})    except Exception as e:        logger.error(f"Error starting focus session: {e}")        return jsonify({'error': 'Failed to start session'}), 500    finally:        return_db_connection(conn)        @app.route('/focus')@login_requireddef focus_session():    return render_template('focus.html')  # eller hvilken template du vil bruke    @app.route('/focus-session/stop/<int:session_id>', methods=['POST'])@login_requireddef stop_focus_session(session_id):    notes = request.form.get('notes', '')        conn = get_db_connection()    if not conn:        return jsonify({'error': 'Database not available'}), 500        try:        cursor = conn.cursor()        cursor.execute("""            UPDATE focus_sessions             SET notes = %s, completed_at = CURRENT_TIMESTAMP            WHERE id = %s AND user_id = %s        """, (notes, session_id, current_user.id))                conn.commit()        cursor.close()                return jsonify({'status': 'stopped'})    except Exception as e:        logger.error(f"Error stopping focus session: {e}")        return jsonify({'error': 'Failed to stop session'}), 500    finally:        return_db_connection(conn)@app.route('/focus-session/complete/<int:session_id>', methods=['POST'])@login_requireddef complete_focus_session(session_id):    notes = request.form.get('notes', '')        conn = get_db_connection()    if not conn:        return jsonify({'error': 'Database not available'}), 500        try:        cursor = conn.cursor()                # Mark session as completed        cursor.execute("""            UPDATE focus_sessions             SET completed = TRUE, notes = %s, completed_at = CURRENT_TIMESTAMP            WHERE id = %s AND user_id = %s        """, (notes, session_id, current_user.id))                # Get session duration        cursor.execute("""            SELECT duration_minutes FROM focus_sessions             WHERE id = %s AND user_id = %s        """, (session_id, current_user.id))                duration = cursor.fetchone()[0]                # Award points        points_earned = award_points(current_user.id, 'focus_session_completed', duration)                conn.commit()        cursor.close()                return jsonify({'status': 'completed', 'points_earned': points_earned})    except Exception as e:        logger.error(f"Error completing focus session: {e}")        return jsonify({'error': 'Failed to complete session'}), 500    finally:        return_db_connection(conn)@app.route('/gentle-mode')@login_requireddef gentle_mode():    """Gentle reminder mode"""    profile = get_user_profile(current_user.id)        # Get only important, non-stressful reminders    my_reminders = get_user_reminders(current_user.id)    gentle_reminders = [r for r in my_reminders if not r['completed']][:3]        return render_template('gentle_mode.html',                          profile=profile,                         reminders=gentle_reminders)@app.route('/test-email')def test_email():    if current_user.is_authenticated:        recipient = current_user.email    else:        recipient = request.args.get('email')            if not recipient:        return "Mangler e-postadresse", 400            success = send_email(        to=recipient,        subject="Test fra Smart P친minner Pro",        html_content=f"<h2>Test e-post</h2><p>Hei {current_user.username if current_user.is_authenticated else 'Test'}!</p><p>Dette er en test e-post fra Smart P친minner Pro.</p>"    )        return f"E-post {'sendt' if success else 'FEILET'} til {recipient}"@app.route('/health')def health_check():    """Health check endpoint"""    return jsonify({        'status': 'healthy',        'timestamp': datetime.now().isoformat(),        'version': '1.0.0'    })@app.route('/admin/setup-db')def setup_database():    """Setup database endpoint"""    success = init_db()    return jsonify({        'status': 'success' if success else 'failed',        'message': 'Database initialized' if success else 'Database initialization failed'    })@app.route('/shared-notes')@login_requireddef shared_notes():    # Get shared notes from JSON since DB is not available    notes = dm.load_data('shared_notes')    user_notes = [n for n in notes if n.get('user_id') == current_user.email]    shared_with_me = [n for n in notes if current_user.email in n.get('shared_with', [])]    all_notes = user_notes + shared_with_me        return render_template('shared_notes.html', notes=all_notes)@app.route('/shared-notes/create', methods=['GET', 'POST'])@login_requireddef create_shared_note():    if request.method == 'POST':        title = request.form.get('title')        content = request.form.get('content', '')                if not title:            flash('Tittel er p친krevd', 'danger')            return redirect(url_for('create_shared_note'))                # Generate random access code        access_code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=6))                note_id = str(uuid.uuid4())        new_note = {            'id': note_id,            'title': title,            'content': content,            'user_id': current_user.email,            'access_code': access_code,            'created_at': datetime.now().isoformat(),            'updated_at': datetime.now().isoformat(),            'members': [                {                    'email': current_user.email,                    'role': 'owner',                    'joined_at': datetime.now().isoformat()                }            ],            'messages': []        }                notes = dm.load_data('shared_notes')        notes.append(new_note)        dm.save_data('shared_notes', notes)                flash('Notat opprettet! Del tilgangskoden med andre.', 'success')        return redirect(url_for('view_shared_note', note_id=note_id))        return render_template('create_shared_note.html')@app.route('/shared-notes/view/<note_id>')@login_requireddef view_shared_note(note_id):    notes = dm.load_data('shared_notes')    note = next((n for n in notes if n.get('id') == note_id), None)        if not note:        flash('Notat ikke funnet', 'danger')        return redirect(url_for('shared_notes'))        # Check if user has access    user_email = current_user.email    is_member = any(m.get('email') == user_email for m in note.get('members', []))    is_owner = note.get('user_id') == user_email        if not (is_member or is_owner):        flash('Du har ikke tilgang til dette notatet', 'danger')        return redirect(url_for('shared_notes'))        return render_template('view_shared_note.html', note=note)@app.route('/shared-notes/join', methods=['GET', 'POST'])@login_requireddef join_shared_note():    if request.method == 'POST':        access_code = request.form.get('access_code')                if not access_code:            flash('Tilgangskode er p친krevd', 'danger')            return redirect(url_for('join_shared_note'))                notes = dm.load_data('shared_notes')        note = next((n for n in notes if n.get('access_code') == access_code), None)                if not note:            flash('Ugyldig tilgangskode', 'danger')            return redirect(url_for('join_shared_note'))                # Check if user is already a member        user_email = current_user.email        is_member = any(m.get('email') == user_email for m in note.get('members', []))                if is_member:            flash('Du er allerede medlem av dette notatet', 'info')            return redirect(url_for('view_shared_note', note_id=note.get('id')))                # Add user as member        note['members'].append({            'email': user_email,            'role': 'member',            'joined_at': datetime.now().isoformat()        })                # Update shared notes        for i, n in enumerate(notes):            if n.get('id') == note.get('id'):                notes[i] = note                break                dm.save_data('shared_notes', notes)                flash('Du er n친 medlem av notatet!', 'success')        return redirect(url_for('view_shared_note', note_id=note.get('id')))        return render_template('join_shared_note.html')@app.route('/shared-notes/update/<note_id>', methods=['POST'])@login_requireddef update_shared_note(note_id):    content = request.form.get('content')        notes = dm.load_data('shared_notes')    note = next((n for n in notes if n.get('id') == note_id), None)        if not note:        flash('Notat ikke funnet', 'danger')        return redirect(url_for('shared_notes'))        # Check if user has access    user_email = current_user.email    is_member = any(m.get('email') == user_email for m in note.get('members', []))    is_owner = note.get('user_id') == user_email        if not (is_member or is_owner):        flash('Du har ikke tilgang til 친 redigere dette notatet', 'danger')        return redirect(url_for('shared_notes'))        # Update note    note['content'] = content    note['updated_at'] = datetime.now().isoformat()        # Update notes list    for i, n in enumerate(notes):        if n.get('id') == note_id:            notes[i] = note            break        dm.save_data('shared_notes', notes)        flash('Notat oppdatert!', 'success')    return redirect(url_for('view_shared_note', note_id=note_id))@app.route('/shared-notes/message/<note_id>', methods=['POST'])@login_requireddef add_message_to_note(note_id):    message_content = request.form.get('message')        if not message_content:        flash('Meldingsinnhold er p친krevd', 'danger')        return redirect(url_for('view_shared_note', note_id=note_id))        notes = dm.load_data('shared_notes')    note = next((n for n in notes if n.get('id') == note_id), None)        if not note:        flash('Notat ikke funnet', 'danger')        return redirect(url_for('shared_notes'))        # Check if user has access    user_email = current_user.email    is_member = any(m.get('email') == user_email for m in note.get('members', []))    is_owner = note.get('user_id') == user_email        if not (is_member or is_owner):        flash('Du har ikke tilgang til dette notatet', 'danger')        return redirect(url_for('shared_notes'))        # Add message    if 'messages' not in note:        note['messages'] = []        note['messages'].append({        'sender': user_email,        'content': message_content,        'timestamp': datetime.now().isoformat()    })        # Update notes list    for i, n in enumerate(notes):        if n.get('id') == note_id:            notes[i] = note            break        dm.save_data('shared_notes', notes)        return redirect(url_for('view_shared_note', note_id=note_id))@app.errorhandler(404)def page_not_found(e):    return render_template('errors/404.html'), 404@app.errorhandler(500)def internal_server_error(e):    return render_template('errors/500.html'), 500@app.errorhandler(403)def forbidden(e):    return render_template('errors/403.html'), 403if __name__ == '__main__':    port = int(os.environ.get('PORT', 5000))    app.run(host='0.0.0.0', port=port, debug=False)